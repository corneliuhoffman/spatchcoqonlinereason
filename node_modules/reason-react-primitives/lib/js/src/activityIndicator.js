// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var Canvas2dRe = require("bs-webapi/lib/js/src/canvas/Canvas2dRe.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");

var match = window.devicePixelRatio;

var devicePixelRatio = (match == null) ? 1.0 : match;

var component = ReasonReact.reducerComponent("ActivityIndicator");

function tupleToColor(param, alpha) {
  return "rgba(" + (String(param[0]) + ("," + (String(param[1]) + ("," + (String(param[2]) + ("," + (Pervasives.string_of_float(alpha) + "0)")))))));
}

function setCanvasRef(canvasRef, param) {
  param[/* state */2][/* context */0][0] = (canvasRef == null) ? /* None */0 : /* Some */[canvasRef.getContext("2d")];
  return /* () */0;
}

function draw(size, color, param) {
  var match = param[/* state */2][/* context */0];
  var match$1 = match[/* contents */0];
  if (match$1) {
    var context = match$1[0];
    var actualSize = size * devicePixelRatio;
    context.clearRect(0.0, 0.0, actualSize, actualSize);
    context.translate(actualSize / 2.0, actualSize / 2.0);
    context.rotate(0.172665);
    context.translate(0.0 - actualSize / 2.0, 0.0 - actualSize / 2.0);
    var partial_arg = actualSize / 2.0;
    var partial_arg$1 = actualSize / 2.0;
    var centeredArc = function (param, param$1, param$2, param$3, param$4) {
      param$4.arc(partial_arg$1, partial_arg, param, param$1, param$2, param$3);
      return /* () */0;
    };
    context.beginPath();
    Curry._5(centeredArc, actualSize * 0.5, Math.PI, 0.0, false, context);
    Curry._5(centeredArc, actualSize * 0.3, 0.0, Math.PI, true, context);
    Canvas2dRe.setFillStyle(context, /* String */0, tupleToColor(color, 1.0));
    context.fill();
    context.closePath();
    context.beginPath();
    Curry._5(centeredArc, actualSize * 0.5, 0.0, Math.PI, false, context);
    Curry._5(centeredArc, actualSize * 0.3, Math.PI, 0.0, true, context);
    var gradient = context.createLinearGradient(0.0, actualSize * 0.5, actualSize * 0.75, actualSize * 0.5);
    gradient.addColorStop(0.5, tupleToColor(color, 1.0));
    gradient.addColorStop(1.0, tupleToColor(color, 0.0));
    Canvas2dRe.setFillStyle(context, /* Gradient */1, gradient);
    context.fill();
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function make(size, color, _) {
  var tick = function (self) {
    var send = self[/* send */4];
    var state = self[/* state */2];
    requestAnimationFrame((function () {
            var match = state[/* cancelNextFrame */1];
            var match$1 = match[/* contents */0];
            if (match$1 !== 0) {
              return /* () */0;
            } else {
              draw(size, color, self);
              return Curry._1(send, /* Draw */0);
            }
          }));
    return /* () */0;
  };
  var newrecord = component.slice();
  newrecord[/* didMount */4] = (function (param) {
      Curry._1(param[/* send */4], /* Draw */0);
      return /* NoUpdate */0;
    });
  newrecord[/* willUnmount */6] = (function (param) {
      param[/* state */2][/* cancelNextFrame */1][0] = /* true */1;
      return /* () */0;
    });
  newrecord[/* render */9] = (function (self) {
      var sizeAttr = String(size | 0);
      var actualSize = String(size * devicePixelRatio | 0);
      return React.createElement("canvas", {
                  ref: Curry._1(self[/* handle */0], setCanvasRef),
                  style: {
                    height: sizeAttr + "px",
                    width: sizeAttr + "px"
                  },
                  height: actualSize,
                  width: actualSize
                });
    });
  newrecord[/* initialState */10] = (function () {
      return /* record */[
              /* context */[/* None */0],
              /* cancelNextFrame */[/* false */0]
            ];
    });
  newrecord[/* reducer */12] = (function (_, state) {
      var match = state[/* cancelNextFrame */1];
      var match$1 = match[/* contents */0];
      if (match$1 !== 0) {
        return /* NoUpdate */0;
      } else {
        return /* SideEffects */Block.__(2, [tick]);
      }
    });
  return newrecord;
}

exports.devicePixelRatio = devicePixelRatio;
exports.component = component;
exports.tupleToColor = tupleToColor;
exports.setCanvasRef = setCanvasRef;
exports.draw = draw;
exports.make = make;
/* match Not a pure module */
